unit uPrincipal;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.Buttons, Vcl.ComCtrls,IniFiles,Math;

type
  TFrmClassifica = class(TForm)
    Edit1: TEdit;
    StatusBar1: TStatusBar;
    BitBtn1: TBitBtn;
    OpenDialog1: TOpenDialog;
    BitBtn2: TBitBtn;
    gpbDados: TGroupBox;
    GroupBox1: TGroupBox;
    lblNumCamadas: TLabel;
    GroupBox2: TGroupBox;
    LblNeucamadas: TLabel;
    procedure ImportaRede(Arquivo:TiniFile);
    procedure BitBtn1Click(Sender: TObject);
    function Classifica(Amostra:String):Integer;
    function StrArrayToFloatArray(AArray:Tarray<string>):Tarray<Real>;
    function MultiplicaArray(Array1:Tarray<real>;Array2:Tarray<real>):Real;
    function LogSig(x:Real):Real;
    procedure BitBtn2Click(Sender: TObject);
    procedure FormCreate(Sender: TObject);
  private
    { Private declarations }
  public
    { Public declarations }
  end;

var
  FrmClassifica: TFrmClassifica;
  Rede :String;
  Camadas:Tarray<string>;
  NumCamadas:Integer;
  NivelAtivacao : real;
  Pesos: array of Tarray<string>;
implementation

{$R *.dfm}

procedure TFrmClassifica.BitBtn1Click(Sender: TObject);
var
  Arquivo:TIniFile;
begin
  if OpenDialog1.Execute then
  begin
    Arquivo := TIniFile.Create(OpenDialog1.FileName);
  end;
  ImportaRede(Arquivo);
end;

procedure TFrmClassifica.BitBtn2Click(Sender: TObject);
begin
  ShowMessage(inttostr(Classifica(Edit1.Text)));
end;

function TFrmClassifica.Classifica(Amostra: String):Integer;
var
  I: Integer;
  AmostraStr,PesoStr : Tarray<string>;
  AmostraFlt,PesoFlt : Tarray<real>;
  J: Integer;
  OutPuts : array of Tarray<real>;
  k: Integer;
begin
  Amostra := '1;' + Amostra;
  AmostraStr := Amostra.Split([';']);
  AmostraFlt := StrArrayToFloatArray(AmostraStr);
  SetLength(OutPuts,NumCamadas);
  for I := 0 to pred(NumCamadas) do
  begin
    SetLength(OutPuts[I],StrToInt(Camadas[I])+1);
    OutPuts[I][0] := 1;
    for J := 1 to StrToInt(Camadas[I]) do
    begin
      PesoStr := Pesos[I][J-1].Split([';']);
      PesoFlt := StrArrayToFloatArray(PesoStr);
      if I = 0 then
        OutPuts[I][J] := LogSig(MultiplicaArray(AmostraFlt,PesoFlt))
      else
        OutPuts[I][J] := LogSig(MultiplicaArray(OutPuts[I-1],PesoFlt))
    end;
  end;
  OutPuts[I-1][0] := 0;
  for k := 1 to pred(Length(OutPuts[I-1])) do
  begin
    if Outputs[I-1][K] > NivelAtivacao then
       Result := k;
  end;

end;

procedure TFrmClassifica.FormCreate(Sender: TObject);
var
  Arquivo:TiniFile;
begin
  if FileExists(ExtractFilePath(Application.ExeName)+'Rede.ini') then
  begin
     Arquivo := TIniFile.Create(ExtractFilePath(Application.ExeName)+'Rede.ini');
     ImportaRede(Arquivo);
  end;

end;

procedure TFrmClassifica.ImportaRede(Arquivo:TiniFile);
var
  PesoCamada:String;
  I: Integer;
begin
  Rede := Arquivo.ReadString('REDE','Camadas','');
  Camadas := Rede.Split([',']);
  NivelAtivacao := StrToFloat(Arquivo.ReadString('REDE','NivelAtivacao',''));
  NumCamadas := Length(Camadas);
  lblNumCamadas.Caption := IntToStr(NumCamadas);
  LblNeucamadas.Caption := Rede;
  SetLength(Pesos,NumCamadas);
  for I := 0 to Pred(NumCamadas) do
  begin
    PesoCamada := Arquivo.ReadString('CAMADA'+ IntToStr(I+1),'Pesos','');
    Pesos[I] := PesoCamada.Split(['|']);
  end;
end;

function TFrmClassifica.LogSig(x: Real): Real;
begin
  Result := 1 /(1+ exp(-x));
end;

function TFrmClassifica.MultiplicaArray(Array1, Array2: Tarray<real>): Real;
var
  Sum :Real;
  I: Integer;
begin
  Sum := 0;
  if Length(Array1) = Length(Array2) then
  begin
    for I := 0 to pred(Length(Array1)) do
    begin
      Sum := Sum + (Array1[I] * Array2[I]);
    end;
    Result := Sum;
  end
  else
  begin
    raise Exception.Create('Vetores incompatíveis');
  end;
end;

function TFrmClassifica.StrArrayToFloatArray(AArray: Tarray<string>): Tarray<Real>;
var
  ArrayFloat : Tarray<Real>;
  I: Integer;
begin
  SetLength(ArrayFloat,Length(AArray));
  for I := 0 to pred(Length(AArray)) do
  begin
    ArrayFloat[I] := StrToFloat(AArray[I]);
  end;

  Result := ArrayFloat;
end;

end.
